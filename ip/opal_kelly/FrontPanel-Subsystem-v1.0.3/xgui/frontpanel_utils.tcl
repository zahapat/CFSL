# ------------------------------------------------------------------------
# File: frontpanel_utils.tcl
#
# Do NOT modify this script.
#
# Copyright (c) 2022-2023 Opal Kelly Incorporated
# ------------------------------------------------------------------------
set lastCount_WI 0;set lastCount_WO 0;set lastCount_TI 0;set lastCount_TO 0;set lastCount_PI 0;set lastCount_PO 0;set lastCount_BTPI 0;set lastCount_BTPO 0;set lastCount_S.WI 0;set lastCount_S.WO 0;set lastCount_S.TI 0;set lastCount_S.TO 0;set lastCount_S.PI 0;set lastCount_S.PO 0;set lastCount_S.BTPI 0;set lastCount_S.BTPO 0;set endpointTypes {WI WO TI TO PI BTPI PO BTPO};foreach type $endpointTypes {;for {set i 0} {$i < 32} {incr i} { ;lappend storedAddressTable($type) 0xff;lappend storedAddressTable(S.$type) 0xff;};};proc returnSupportedBoards {} {;variable supportedBoards;set text "";foreach board [dict keys $supportedBoards] {;append text "," $board;};return $text;};proc updateAddressParam { tableType tableIndex paramObject} {;variable storedAddressTable;upvar ${paramObject} paramObjectCaller;set paramObject ${paramObjectCaller};set_property value [lindex $storedAddressTable($tableType) $tableIndex] $paramObject;};proc updateStoredAddressTable { tableType tableIndex paramObject} {;variable storedAddressTable;upvar ${paramObject} paramObjectCaller;set paramObject ${paramObjectCaller};set userAddress [get_property value $paramObject];lset storedAddressTable($tableType) $tableIndex $userAddress;};proc updateAddressParamIfUnused { endpointType tableIndex paramObject numEndpoints} {;upvar ${paramObject} paramObjectCaller;set paramObject ${paramObjectCaller};variable lastCount_$endpointType;upvar ${numEndpoints} numEndpointsObjectCaller;set numEndpointsObject ${numEndpointsObjectCaller};set numEndpoints [get_property value $numEndpointsObject];if {$tableIndex >= $numEndpoints} {;set_property value 0xff $paramObject;};set lastCount_$endpointType $numEndpoints;};proc updateAddressTable { checkStartAddress endpointType numEndpoints  } {;upvar ${numEndpoints} numEndpointsObjectCaller;set numEndpointsObject ${numEndpointsObjectCaller};set numEndpoints [get_property value $numEndpointsObject];variable lastCount_$endpointType;if {[set lastCount_$endpointType] == $numEndpoints} {;return;};variable storedAddressTable;for {set i [set lastCount_$endpointType]} { $i < $numEndpoints} {incr i} {;set done 0;for {set j 0} { $j < $numEndpoints} {incr j} {;set possibleSolution [expr $checkStartAddress + $j];for {set k 0} { $k < $numEndpoints} {incr k} {;set userStoredAddress [lindex $storedAddressTable($endpointType) $k];if {$possibleSolution == $userStoredAddress} {;break;} elseif {$k == $numEndpoints - 1} {;lset storedAddressTable($endpointType) $i [format 0x%02x $possibleSolution];set done 1;break;};};if {$done} {break};};};for {set i $numEndpoints} { $i < 32} {incr i} {;lset storedAddressTable($endpointType) $i 0xff;};set lastCount_$endpointType $numEndpoints;};proc updateAddressTableForPipes { checkStartAddress endpointType endpointTypeOther numEndpoints } {;variable lastCount_$endpointType;upvar ${numEndpoints} numEndpointsObjectCaller;set numEndpointsObject ${numEndpointsObjectCaller};set numEndpoints [get_property value $numEndpointsObject];if {[set lastCount_$endpointType] == $numEndpoints} {;return;};variable lastCount_$endpointTypeOther;set numEndpointsOther [set lastCount_$endpointTypeOther];variable storedAddressTable;for {set i [set lastCount_$endpointType]} { $i < $numEndpoints} {incr i} {;set done 0;for {set j 0} { $j < $numEndpoints + $numEndpointsOther} {incr j} {;set continue 0;set possibleSolution [expr $checkStartAddress + $j];for {set k 0} { $k < $numEndpoints} {incr k} {;set userStoredAddress [lindex $storedAddressTable($endpointType) $k];if {$possibleSolution == $userStoredAddress} {;set continue 1;break;} elseif {$k == $numEndpoints - 1 && $numEndpointsOther == 0} {;lset storedAddressTable($endpointType) $i [format 0x%02x $possibleSolution];set done 1;break;};};if {$continue} {continue};if {$done} {break};for {set k 0} { $k < $numEndpointsOther} {incr k} {;set userStoredAddress [lindex $storedAddressTable($endpointTypeOther) $k];if {$possibleSolution == $userStoredAddress} {;break;} elseif {$k == $numEndpointsOther - 1} {;lset storedAddressTable($endpointType) $i [format 0x%02x $possibleSolution];set done 1;break;};};if {$done} {break};};};for {set i $numEndpoints} { $i < 32} {incr i} {;lset storedAddressTable($endpointType) $i 0xff;};set lastCount_$endpointType $numEndpoints;};proc validateParam { boardParam countParam endpointType endpointIndexUnderTest rangeMin rangeMax address_0 address_1 address_2 address_3 address_4 address_5 address_6 address_7 address_8 address_9 address_10 address_11 address_12 address_13 address_14 address_15 address_16 address_17 address_18 address_19 address_20 address_21 address_22 address_23 address_24 address_25 address_26 address_27 address_28 address_29 address_30 address_31 } {;variable secondaryEnabledBoards;upvar $boardParam boardParamObjectCaller;upvar $countParam countParamObjectCaller;upvar [set address_$endpointIndexUnderTest] testAgainstAddressObjectCaller;set testAgainstAddressObject ${testAgainstAddressObjectCaller};set testAgainstAddress [get_property value $testAgainstAddressObject];set board [get_property value $boardParamObjectCaller];set numEndpoints [get_property value $countParamObjectCaller];if {[string equal -length 2 "S." $endpointType] && $numEndpoints != "0" && !($board in $secondaryEnabledBoards)} {;return false;};if {[string equal -length 2 "S." $endpointType] && $testAgainstAddress != "0xff" && !($board in $secondaryEnabledBoards)} {;set_property errmsg "Secondary host interface is not supported on the $board" $testAgainstAddressObject;return false;};if {$endpointIndexUnderTest >= $numEndpoints} {;if {$testAgainstAddress != "0xff"} {;if {$numEndpoints == 0} {;set validBins "None, CONFIG.${endpointType}.COUNT is 0";};for {set i 0} {$i < $numEndpoints} {incr i} {;append validBins "CONFIG.$endpointType.ADDR_$i ";};set_property errmsg "Address bin CONFIG.$endpointType.ADDR_$endpointIndexUnderTest is out of range of CONFIG.${endpointType}.COUNT ($numEndpoints). Valid address bins for user modification are: $validBins" $testAgainstAddressObject;return false;};return true;};if {!($rangeMin <= $testAgainstAddress &&  $testAgainstAddress <= $rangeMax)} {;set_property errmsg "Address is out of bounds. Must be between $rangeMin - $rangeMax" $testAgainstAddressObject;return false;};for {set i 0} {$i < $numEndpoints} {incr i} {;if {$i == $endpointIndexUnderTest} {;continue;};upvar [set address_$i] addressObjectCaller;set addressObject_i ${addressObjectCaller};set Address_i [get_property value $addressObject_i];if {$testAgainstAddress == $Address_i} {;set_property errmsg "You cannot have two endpoints with the same address" $testAgainstAddressObject ;return false;};};return true;};proc validatePipeParam { boardParam countParam endpointType endpointIndexUnderTest rangeMin rangeMax address_0 address_1 address_2 address_3 address_4 address_5 address_6 address_7 address_8 address_9 address_10 address_11 address_12 address_13 address_14 address_15 address_16 address_17 address_18 address_19 address_20 address_21 address_22 address_23 address_24 address_25 address_26 address_27 address_28 address_29 address_30 address_31 endpointTypeOther otherAddress_0 otherAddress_1 otherAddress_2 otherAddress_3 otherAddress_4 otherAddress_5 otherAddress_6 otherAddress_7 otherAddress_8 otherAddress_9 otherAddress_10 otherAddress_11 otherAddress_12 otherAddress_13 otherAddress_14 otherAddress_15 otherAddress_16 otherAddress_17 otherAddress_18 otherAddress_19 otherAddress_20 otherAddress_21 otherAddress_22 otherAddress_23 otherAddress_24 otherAddress_25 otherAddress_26 otherAddress_27 otherAddress_28 otherAddress_29 otherAddress_30 otherAddress_31 } {;variable secondaryEnabledBoards;upvar $boardParam boardParamObjectCaller;upvar $countParam countParamObjectCaller;upvar [set address_$endpointIndexUnderTest] testAgainstAddressObjectCaller;set testAgainstAddressObject ${testAgainstAddressObjectCaller};set testAgainstAddress [get_property value $testAgainstAddressObject];variable lastCount_$endpointTypeOther;set numEndpoints [get_property value $countParamObjectCaller];set numOtherEndpoints [set lastCount_$endpointTypeOther];set board [get_property value $boardParamObjectCaller];if {[string equal -length 2 "S." $endpointType] && $numEndpoints != "0" && !($board in $secondaryEnabledBoards)} {;return false;};if {[string equal -length 2 "S." $endpointType] && $testAgainstAddress != "0xff" && !($board in $secondaryEnabledBoards)} {;set_property errmsg "Secondary host interface is not supported on the $board" $testAgainstAddressObject;return false;};if {$endpointIndexUnderTest >= $numEndpoints} {;if {$testAgainstAddress != "0xff"} {;if {$numEndpoints == 0} {;set validBins "None, CONFIG.${endpointType}.COUNT is 0";};for {set i 0} {$i < $numEndpoints} {incr i} {;append validBins "CONFIG.$endpointType.ADDR_$i ";};set_property errmsg "Address bin CONFIG.$endpointType.ADDR_$endpointIndexUnderTest is out of range of CONFIG.${endpointType}.COUNT ($numEndpoints). Valid address bins for user modification are: $validBins" $testAgainstAddressObject;return false;};return true;};if {!($rangeMin <= $testAgainstAddress &&  $testAgainstAddress <= $rangeMax)} {;set_property errmsg "Address is out of bounds. Must be between $rangeMin - $rangeMax" $testAgainstAddressObject;return false;};for {set i 0} {$i < $numEndpoints} {incr i} {;if {$i == $endpointIndexUnderTest} {;continue;};upvar [set address_$i] addressObjectCaller;set addressObject_i ${addressObjectCaller};set Address_i [get_property value $addressObject_i];if {$testAgainstAddress == $Address_i} {;set_property errmsg "You cannot have two endpoints with the same address" $testAgainstAddressObject ;return false;};};for {set i 0} {$i < $numOtherEndpoints} {incr i} {;upvar [set otherAddress_$i] otherAddressObjectCaller;set otherAddressObject_i ${otherAddressObjectCaller};set otherAddressObject_i [get_property value $otherAddressObject_i];if {$testAgainstAddress == $otherAddressObject_i} {;set_property errmsg "You cannot have two endpoints with the same address" $testAgainstAddressObject ;return false;};};return true;};proc validatePipeRange { boardParam numEndpoints numOtherEndpoints endpointType } {;if {[baselineErrorChecking]} {;return true;};upvar ${numEndpoints} numEndpointsObjectCaller ;upvar ${numOtherEndpoints} numOtherEndpointsObjectCaller;set numEndpointsObject ${numEndpointsObjectCaller};set numOtherEndpointsObject ${numOtherEndpointsObjectCaller}    ;set numEndpoints [get_property value $numEndpointsObject];set numOtherEndpoints [get_property value $numOtherEndpointsObject];if {$numEndpoints + $numOtherEndpoints > 32} {;set_property errmsg "Total number of standard and block throttle (BT) Pipes cannot exceed 32 for a given direction (In/Out)" $numEndpointsObject;return false;};variable secondaryEnabledBoards;upvar $boardParam boardParamObjectCaller;set board [get_property value $boardParamObjectCaller];if {[string equal -length 2 "S." $endpointType] && $numEndpoints != "0" && !($board in $secondaryEnabledBoards)} {;set_property errmsg "Secondary host interface is not supported on the $board" $numEndpointsObject;return false;};return true;};proc validateRange { boardParam numEndpoints endpointType } {;if {[baselineErrorChecking]} {;return true;};upvar ${numEndpoints} numEndpointsObjectCaller ;set numEndpointsObject ${numEndpointsObjectCaller}   ;set numEndpoints [get_property value $numEndpointsObject];if {$numEndpoints > 32} {;set_property errmsg "Total number of endpoints can not exceed 32" $numEndpointsObject;return false;};variable secondaryEnabledBoards;upvar $boardParam boardParamObjectCaller;set board [get_property value $boardParamObjectCaller];if {[string equal -length 2 "S." $endpointType] && $numEndpoints != "0" && !($board in $secondaryEnabledBoards)} {;set_property errmsg "Secondary host interface is not supported on the $board" $numEndpointsObject;return false;};return true;};proc updateTableDynamically {ipinst numEndpoints endpointType} {;upvar ${ipinst} ipinstObjectCaller;set ipinstObject ${ipinstObjectCaller};upvar ${numEndpoints} numEndpointsObjectCaller;set numEndpointsObject ${numEndpointsObjectCaller};set numEndpoints [get_property value $numEndpointsObject];if {$numEndpoints == 0} {;set_property visible false [ipgui::get_tablespec [set endpointType]_table -of $ipinstObject];} else {;set startIndex [expr $numEndpoints + 2];set hiddenIndexs $startIndex;for {set i $startIndex} { $i < 35} {incr i} {;append hiddenIndexes "," $i;};set_property hidden_rows $hiddenIndexes [ipgui::get_tablespec [set endpointType]_table -of $ipinstObject];set_property visible true [ipgui::get_tablespec [set endpointType]_table -of $ipinstObject];};};proc secondaryCountBackToDefault {boardParam countParam ParamPrefix} {;if {[baselineErrorChecking]} {;return true;};if {$ParamPrefix != "S."} {;return false;};variable secondaryEnabledBoards;upvar $boardParam boardParamObjectCaller;set board [get_property value $boardParamObjectCaller];upvar ${countParam} numEndpointsObjectCaller;set numEndpoints [get_property value $numEndpointsObjectCaller];if {$numEndpoints != "0" && !($board in $secondaryEnabledBoards)} {;set_property value 0 $numEndpointsObjectCaller;};return false;};
